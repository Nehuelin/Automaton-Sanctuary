EXAMPLES

	// 1) Given the alphabet Σ = {0, 1}, the following DFA accepts all binary strings ending with at least two consecutive '1's

        HashSet<Character> alphabet = new HashSet<>();

        alphabet.add('0');
        alphabet.add('1');

        System.out.println(alphabet.toString());

        HashSet<String> states = new HashSet<>();
        states.add("q0");
        states.add("q1");
        states.add("q2");

        for(String state : states) {
            System.out.println(state);
        }

        HashSet<String> acceptStates = new HashSet<>();
        acceptStates.add("q2");

        Map<String, Map<Character, String>> transitions = new HashMap<>();

        Map<Character, String> q0transitions = new HashMap<>();
        q0transitions.put('0', "q0");
        q0transitions.put('1', "q1");

        Map<Character, String> q1transitions = new HashMap<>();
        q1transitions.put('0', "q0");
        q1transitions.put('1', "q2");

        Map<Character, String> q2transitions = new HashMap<>();
        q2transitions.put('0', "q0");
        q2transitions.put('1', "q2");

        transitions.put("q0", q0transitions);
        transitions.put("q1", q1transitions);
        transitions.put("q2", q2transitions);

        DFA automaton = new DFA(states, alphabet, transitions, "q0", acceptStates);

        System.out.println(automaton.accept("100011")); // Should return true
        System.out.println(automaton.accept("10101")); // Should return false

        System.out.println(automaton.getTransitionFunction().toString());



	// 2) Given the alphabet Σ = {0, 1}, the following DFA accepts all binary strings that have at most two '0's in them.
 
        HashSet<Character> alphabet = new HashSet<>();

        alphabet.add('0');
        alphabet.add('1');

        System.out.println(alphabet.toString());

        HashSet<String> states = new HashSet<>();
        states.add("q0");
        states.add("q1");
        states.add("q2");
        states.add("q3");

        for(String state : states) {
            System.out.println(state);
        }

        HashSet<String> acceptStates = new HashSet<>();
        acceptStates.add("q0");
        acceptStates.add("q1");
        acceptStates.add("q2");

        Map<String, Map<Character, String>> transitions = new HashMap<>();

        Map<Character, String> q0transitions = new HashMap<>();
        q0transitions.put('0', "q1");
        q0transitions.put('1', "q0");

        Map<Character, String> q1transitions = new HashMap<>();
        q1transitions.put('0', "q2");
        q1transitions.put('1', "q1");

        Map<Character, String> q2transitions = new HashMap<>();
        q2transitions.put('0', "q3");
        q2transitions.put('1', "q2");

        Map<Character, String> q3transitions = new HashMap<>();
        q3transitions.put('0', "q3");
        q3transitions.put('1', "q3");

        transitions.put("q0", q0transitions);
        transitions.put("q1", q1transitions);
        transitions.put("q2", q2transitions);
        transitions.put("q3", q3transitions);

        DFA automaton = new DFA(states, alphabet, transitions, "q0", acceptStates);

        System.out.println(automaton.accept("10011")); // Should return true
        System.out.println(automaton.accept("10001")); // Should return false

        System.out.println(automaton.getTransitionFunction().toString());



	// 3) Given the alphabet Σ = {0, 1}, the following DFA accepts all binary strings that have an even number of '0s' and '1s'.

        HashSet<Character> alphabet = new HashSet<>();

        alphabet.add('0');
        alphabet.add('1');

        System.out.println(alphabet.toString());

        HashSet<String> states = new HashSet<>();
        states.add("q0");
        states.add("q1");
        states.add("q2");
        states.add("q3");

        for(String state : states) {
            System.out.println(state);
        }

        HashSet<String> acceptStates = new HashSet<>();
        acceptStates.add("q0");

        Map<String, Map<Character, String>> transitions = new HashMap<>();

        Map<Character, String> q0transitions = new HashMap<>();
        q0transitions.put('0', "q1");
        q0transitions.put('1', "q3");

        Map<Character, String> q1transitions = new HashMap<>();
        q1transitions.put('0', "q0");
        q1transitions.put('1', "q2");

        Map<Character, String> q2transitions = new HashMap<>();
        q2transitions.put('0', "q3");
        q2transitions.put('1', "q1");

        Map<Character, String> q3transitions = new HashMap<>();
        q3transitions.put('0', "q2");
        q3transitions.put('1', "q0");

        transitions.put("q0", q0transitions);
        transitions.put("q1", q1transitions);
        transitions.put("q2", q2transitions);
        transitions.put("q3", q3transitions);

        DFA automaton = new DFA(states, alphabet, transitions, "q0", acceptStates);

        System.out.println(automaton.accept("100111")); // Should return true
        System.out.println(automaton.accept("1010010")); // Should return false

        System.out.println(automaton.getTransitionFunction().toString());